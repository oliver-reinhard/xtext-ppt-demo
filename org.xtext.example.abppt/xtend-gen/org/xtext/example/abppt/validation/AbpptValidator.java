/**
 * generated by Xtext 2.16.0
 */
package org.xtext.example.abppt.validation;

import com.google.common.collect.Maps;
import java.util.HashMap;
import org.eclipse.emf.common.util.EList;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.ExclusiveRange;
import org.xtext.example.abppt.abppt.AbpptPackage;
import org.xtext.example.abppt.abppt.Presentation;
import org.xtext.example.abppt.abppt.SlideContent;
import org.xtext.example.abppt.validation.AbstractAbpptValidator;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class AbpptValidator extends AbstractAbpptValidator {
  @Check
  public void checkSlideReferencesByPresentation(final Presentation presentation) {
    final HashMap<SlideContent, Integer> map = Maps.<SlideContent, Integer>newHashMap();
    EList<SlideContent> _slides = presentation.getSlides();
    for (final SlideContent slide : _slides) {
      {
        Integer count = map.get(slide);
        if ((count == null)) {
          count = Integer.valueOf(0);
        }
        map.put(slide, Integer.valueOf(((count).intValue() + 1)));
      }
    }
    int _size = presentation.getSlides().size();
    ExclusiveRange _doubleDotLessThan = new ExclusiveRange(0, _size, true);
    for (final Integer i : _doubleDotLessThan) {
      {
        final SlideContent slide_1 = presentation.getSlides().get((i).intValue());
        Integer _get = map.get(slide_1);
        boolean _greaterThan = ((_get).intValue() > 1);
        if (_greaterThan) {
          this.warning("Slide is contained in presentation more than once", presentation, AbpptPackage.eINSTANCE.getPresentation_Slides(), (i).intValue());
        }
      }
    }
  }
}
